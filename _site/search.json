[
  {
    "objectID": "document_dir/about/about.html",
    "href": "document_dir/about/about.html",
    "title": "Purpose",
    "section": "",
    "text": "This R guide was created by Aale J. Agans at the Hawkwood Research Group for the Bowdoin College Biology Department. The purpose of the guide is to provide a comprehensive intro to the usage of R in an academic setting, establish good practices to enable further learning, and the specific applications of R for the biological sciences. This guide is currently under development!"
  },
  {
    "objectID": "document_dir/about/author_info.html",
    "href": "document_dir/about/author_info.html",
    "title": "The Author",
    "section": "",
    "text": "Aale J. Agans is an undergraduate student at Bowdoin College majoring in evolutionary and ecological biology with interests in ecological genetics and the evolution of symbiosis in terrestrial systems. As a proponent for open and free access in academia, most of their work in bioinformatics is developing applications and pipelines that are accessible and easy to use for researchers at all levels."
  },
  {
    "objectID": "document_dir/about/author_info.html#education",
    "href": "document_dir/about/author_info.html#education",
    "title": "The Author",
    "section": "Education",
    "text": "Education\nBowdoin College | Brunswick, ME\nB.A. in Biology; Evolution, Ecology, and Marine Biology Concentration | August 2021 - Present"
  },
  {
    "objectID": "document_dir/about/author_info.html#experience",
    "href": "document_dir/about/author_info.html#experience",
    "title": "The Author",
    "section": "Experience",
    "text": "Experience\nBioinformatics Lead | Hawkwood Research Group | August 2023 - Present\nResearch Assistant | Bowdoin College | January 2023 - Present\nR Learning Assistant | Bowdoin College | August 2023 - Present"
  },
  {
    "objectID": "document_dir/about/guide_license.html",
    "href": "document_dir/about/guide_license.html",
    "title": "Guide License",
    "section": "",
    "text": "This guide and all related software is licensed under the MIT license. The author and/or copyright holder(s) maintain the right to change the license used.\nCopyright (c) 2023 Aale J. Agans & Hawkwood Research Group\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "document_dir/about/other_software_licenses.html",
    "href": "document_dir/about/other_software_licenses.html",
    "title": "Incorporated Software & Media",
    "section": "",
    "text": "The R software is licensed under the General Public License version 2 or Later. The language of the licensing can be accessed using the command below:\nRShowDoc(\"GPL-3\")\nThe tidyverse packages, including dplyr, ggplot2, tidyr, and others are licensed under the MIT license, which can be accessed here.\nQuarto, the framework used to build this guide, is licensed under the General Public License version 2, which can be accessed here.\nThe RStudio IDE software is provided under the Affero General Public License version 3, which can be accessed here.\nThe webR package is licensed under the MIT license with the binaries licensed under the General Public License version 3. Information can be accessed here.\nThe icon is an adaption, (c) Joseph Gage, some rights reserved (CC BY-SA)"
  },
  {
    "objectID": "document_dir/about/other_software_licenses.html#licensing-statements-for-incorporated-software",
    "href": "document_dir/about/other_software_licenses.html#licensing-statements-for-incorporated-software",
    "title": "Incorporated Software & Media",
    "section": "",
    "text": "The R software is licensed under the General Public License version 2 or Later. The language of the licensing can be accessed using the command below:\nRShowDoc(\"GPL-3\")\nThe tidyverse packages, including dplyr, ggplot2, tidyr, and others are licensed under the MIT license, which can be accessed here.\nQuarto, the framework used to build this guide, is licensed under the General Public License version 2, which can be accessed here.\nThe RStudio IDE software is provided under the Affero General Public License version 3, which can be accessed here.\nThe webR package is licensed under the MIT license with the binaries licensed under the General Public License version 3. Information can be accessed here.\nThe icon is an adaption, (c) Joseph Gage, some rights reserved (CC BY-SA)"
  },
  {
    "objectID": "document_dir/basics/working_r.html",
    "href": "document_dir/basics/working_r.html",
    "title": "Variables and Arithmetic",
    "section": "",
    "text": "Unlike other statistical programs you may be familiar with, such as Prism, R does not have a GUI (graphical user interface). Rather, R is a programming language. Instead of clicking buttons and choosing a specific statistical test from a list, you have to build a command and run it.\nAt the most basic level, R is about loading data into objects (also called variables), doing something to that object using a function, and outputting that modified data to a new object. In order to assign data to an object, one uses an assignment operator. For example:\n\nobject_1 &lt;- 1\nanother_object &lt;- object_1 + object_1\nprint(another_object)\n\n[1] 2\n\n\n\n\nIn this case, we assigned the value 1 to the variable object_1 using the assignment operator &lt;-. Whatever is to the left of the assignment operator is the name of the variable. Whatever is to the right of the operator is what the variable name is assigned to.\n\n\n\nVariables can be as simple as a number such as 1, to as complex as a data set composed of hundreds of rows and columns. Variable names can be composed of any alphanumeric characters along with periods and underscores. However, the variable name can not start with a number or an underscore. Which variable assignments would work?\n1var1 &lt;- 5\nvar2 &lt;- \"hello!\"\n23var &lt;- \"Cats are cool\"\n\n1\n\nThis would work!\n\n2\n\nThis one starts with a number, so it would not work\n\n\nVariables are going to store data that you work with throughout your R script, so there are a few conventions on how to name them to make their use as easy as possible. Try to aim for short and descriptive variable names. If you have to repeatedly use the variable, a variable name that is long will be cumbersome to use. Additionally, for ease of reading your code, a descriptive name of what the object is makes it easier for understanding what is going on. For example:\nlist_of_my_favorite_odd_numbers &lt;- c(1,9,19) \n#This is a long name! \n#Do you want to have to type it everytime you want to use this object?\n\nvar1 &lt;- 15 \n#This name is not descriptive. \n#When you later use var1 in your script, are you going to know what it stores?\n\n#Lets try to improve those names\nfav_odd_nums &lt;- c(1,9,19)\n#This is shorter than the original but just as descriptive\n\nfifteen &lt;- 15\n#Concise and descriptive!\nAnother convention is how to separate words in your variable name. R will not allow you to put spaces in a variable name, as it interprets that as two different variables. The R style guide recommends using underscores (_) as the connector between words in your variable name. This style is called Snake Case, for it was popularized by the programming language Python. An example are the variables with multiple words in the above code blocks. Three other naming conventions that are common in R are Pascale Case, Camel Case and Period Separated.\nsnake_case &lt;- \"This is Snake Case because the words are separated by an _\"\nPascaleCase &lt;- \"Each word is capitalized in Pascale Case\"\ncamelCase &lt;- \"Words after the first one are capitalized in Camel Case\"\nperiod.separated &lt;- \"Words are separated by a period\"\nWhile there is no functional reason to not use these styles, the R style guide does suggest the usage of Snake Case due to removing ambiguity. However, this is a recent change. If you look at older R code, you will see that the Period Separated convention is widely used.\nPlease just try to stay consistent in your naming conventions, and while we recommend the usage of Snake Case, it is not required.\n\n\n\n\n\n\nTip\n\n\n\nR is case sensitive! A variable name of years_since_x is not the same as Years_since_x or any other variation. R is extremely pedantic, it will do exactly what you tell it to do, not what you want it to do. Creating different variables that only differ in case is highly discouraged due to a high chance of later confusion.\n\n\n\n\n\nR has many other operators that can be used beyond the assignment operator. Listed below are additional assignment and arithmetic operators. Other operators do exist and will be explained in a later section.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nVariable assignment operator\nAssignment\n&lt;-\nAssign an object to a variable name\n\n\nParameter assignment operator\nAssignment\n=\nAssign an object to a parameter in a function\n\n\nAddition operator\nArithmetic\n+\nAdd numerics together\n\n\nSubtraction operator\nArithmetic\n-\nSubtracts numerics from one another\n\n\nMultiplication operator\nArithmetic\n*\nMultiplies numerics together\n\n\nDivision operator\nArithmetic\n/\nDivides numerics\n\n\nExponent operator\nArithmetic\n^\nFinds the value of a numeric to a given exponent\n\n\nModulus operator\nArithmetic\n%%\nReturns the remainder when dividing numerics\n\n\nInteger division operator\nArithmetic\n%/%\nReturns a numeric truncated to the nearest integer when dividing numerics\n\n\n\n\n12 + 5\n10 - 3\n3*4\n76/4\n4^2\n12%%5\n24%/%5\n\n[1] 17\n[1] 7\n[1] 12\n[1] 19\n[1] 16\n[1] 2\n[1] 4\n\n\nOne core aspect of R arithmetic operators is that they are vectorized. If you have a vector containing multiple numbers and add it to a different vector containing other numbers, the first set of numbers will be added together, and so will the second set, and so on until every element set is added together.\n\nvec_1 &lt;- c(1,2,3)\nvec_2 &lt;- c(10, 20, 30)\nvec_1 + vec_2\n\n[1] 11 22 33"
  },
  {
    "objectID": "document_dir/basics/working_r.html#r-syntax-structure",
    "href": "document_dir/basics/working_r.html#r-syntax-structure",
    "title": "Variables and Arithmetic",
    "section": "",
    "text": "Unlike other statistical programs you may be familiar with, such as Prism, R does not have a GUI (graphical user interface). Rather, R is a programming language. Instead of clicking buttons and choosing a specific statistical test from a list, you have to build a command and run it.\nAt the most basic level, R is about loading data into objects (also called variables), doing something to that object using a function, and outputting that modified data to a new object. In order to assign data to an object, one uses an assignment operator. For example:\n\nobject_1 &lt;- 1\nanother_object &lt;- object_1 + object_1\nprint(another_object)\n\n[1] 2\n\n\n\n\nIn this case, we assigned the value 1 to the variable object_1 using the assignment operator &lt;-. Whatever is to the left of the assignment operator is the name of the variable. Whatever is to the right of the operator is what the variable name is assigned to.\n\n\n\nVariables can be as simple as a number such as 1, to as complex as a data set composed of hundreds of rows and columns. Variable names can be composed of any alphanumeric characters along with periods and underscores. However, the variable name can not start with a number or an underscore. Which variable assignments would work?\n1var1 &lt;- 5\nvar2 &lt;- \"hello!\"\n23var &lt;- \"Cats are cool\"\n\n1\n\nThis would work!\n\n2\n\nThis one starts with a number, so it would not work\n\n\nVariables are going to store data that you work with throughout your R script, so there are a few conventions on how to name them to make their use as easy as possible. Try to aim for short and descriptive variable names. If you have to repeatedly use the variable, a variable name that is long will be cumbersome to use. Additionally, for ease of reading your code, a descriptive name of what the object is makes it easier for understanding what is going on. For example:\nlist_of_my_favorite_odd_numbers &lt;- c(1,9,19) \n#This is a long name! \n#Do you want to have to type it everytime you want to use this object?\n\nvar1 &lt;- 15 \n#This name is not descriptive. \n#When you later use var1 in your script, are you going to know what it stores?\n\n#Lets try to improve those names\nfav_odd_nums &lt;- c(1,9,19)\n#This is shorter than the original but just as descriptive\n\nfifteen &lt;- 15\n#Concise and descriptive!\nAnother convention is how to separate words in your variable name. R will not allow you to put spaces in a variable name, as it interprets that as two different variables. The R style guide recommends using underscores (_) as the connector between words in your variable name. This style is called Snake Case, for it was popularized by the programming language Python. An example are the variables with multiple words in the above code blocks. Three other naming conventions that are common in R are Pascale Case, Camel Case and Period Separated.\nsnake_case &lt;- \"This is Snake Case because the words are separated by an _\"\nPascaleCase &lt;- \"Each word is capitalized in Pascale Case\"\ncamelCase &lt;- \"Words after the first one are capitalized in Camel Case\"\nperiod.separated &lt;- \"Words are separated by a period\"\nWhile there is no functional reason to not use these styles, the R style guide does suggest the usage of Snake Case due to removing ambiguity. However, this is a recent change. If you look at older R code, you will see that the Period Separated convention is widely used.\nPlease just try to stay consistent in your naming conventions, and while we recommend the usage of Snake Case, it is not required.\n\n\n\n\n\n\nTip\n\n\n\nR is case sensitive! A variable name of years_since_x is not the same as Years_since_x or any other variation. R is extremely pedantic, it will do exactly what you tell it to do, not what you want it to do. Creating different variables that only differ in case is highly discouraged due to a high chance of later confusion.\n\n\n\n\n\nR has many other operators that can be used beyond the assignment operator. Listed below are additional assignment and arithmetic operators. Other operators do exist and will be explained in a later section.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nVariable assignment operator\nAssignment\n&lt;-\nAssign an object to a variable name\n\n\nParameter assignment operator\nAssignment\n=\nAssign an object to a parameter in a function\n\n\nAddition operator\nArithmetic\n+\nAdd numerics together\n\n\nSubtraction operator\nArithmetic\n-\nSubtracts numerics from one another\n\n\nMultiplication operator\nArithmetic\n*\nMultiplies numerics together\n\n\nDivision operator\nArithmetic\n/\nDivides numerics\n\n\nExponent operator\nArithmetic\n^\nFinds the value of a numeric to a given exponent\n\n\nModulus operator\nArithmetic\n%%\nReturns the remainder when dividing numerics\n\n\nInteger division operator\nArithmetic\n%/%\nReturns a numeric truncated to the nearest integer when dividing numerics\n\n\n\n\n12 + 5\n10 - 3\n3*4\n76/4\n4^2\n12%%5\n24%/%5\n\n[1] 17\n[1] 7\n[1] 12\n[1] 19\n[1] 16\n[1] 2\n[1] 4\n\n\nOne core aspect of R arithmetic operators is that they are vectorized. If you have a vector containing multiple numbers and add it to a different vector containing other numbers, the first set of numbers will be added together, and so will the second set, and so on until every element set is added together.\n\nvec_1 &lt;- c(1,2,3)\nvec_2 &lt;- c(10, 20, 30)\nvec_1 + vec_2\n\n[1] 11 22 33"
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html",
    "href": "document_dir/basics/using_rstudio.html",
    "title": "Using R and RStudio",
    "section": "",
    "text": "Traditionally, R is installed to your local computer, allowing you to use it wherever and whenever you want to. However, here at Bowdoin, IT hosts an RStudio server on the High Performance Computing cluster. This allows you to not bog down your computer if you are running long, complex code, and it makes sure everyone has the same R environment when used in lab. The server is accessible from rstudio.bowdoin.edu as long as you are either connected to the Bowdoin internet network or to the Bowdoin VPN. Once there, you will be asked to sign in with your Bowdoin username and password. Make sure you use your Bowdoin username, and not your email! For example, if your email is ssdeeds@bowdoin.edu, then your username is ssdeeds.\n\n\n\nBowdoin RStudio log-in screen\n\n\nOnce you are logged in, you will now see the RStudio interface. This is where you can start using R!"
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html#accessing-r-at-bowdoin",
    "href": "document_dir/basics/using_rstudio.html#accessing-r-at-bowdoin",
    "title": "Using R and RStudio",
    "section": "",
    "text": "Traditionally, R is installed to your local computer, allowing you to use it wherever and whenever you want to. However, here at Bowdoin, IT hosts an RStudio server on the High Performance Computing cluster. This allows you to not bog down your computer if you are running long, complex code, and it makes sure everyone has the same R environment when used in lab. The server is accessible from rstudio.bowdoin.edu as long as you are either connected to the Bowdoin internet network or to the Bowdoin VPN. Once there, you will be asked to sign in with your Bowdoin username and password. Make sure you use your Bowdoin username, and not your email! For example, if your email is ssdeeds@bowdoin.edu, then your username is ssdeeds.\n\n\n\nBowdoin RStudio log-in screen\n\n\nOnce you are logged in, you will now see the RStudio interface. This is where you can start using R!"
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html#rstudio-interface",
    "href": "document_dir/basics/using_rstudio.html#rstudio-interface",
    "title": "Using R and RStudio",
    "section": "RStudio Interface",
    "text": "RStudio Interface\nRStudio is a type of software called an IDE (Integrated Developer Environment) that makes using R much easier than using R directly.\n\n\n\nRStudio Interface\n\n\nThe interface is split into 4 sections by default.\n\nThe top left is where files are open and accessible. Generally, this is where you are creating an R script, which is essentially a text file with a list of R commands that are saved so you can use them later. You can run R code directly from the script through two main methods. If you highlight multiple rows of R code or click so your cursor is on one row and click the run button with the green arrow, then R will run the selected line(s) of code and the output will show up in the console (discussed below). If you want to run the whole file, you can use the Source button.\nThe bottom left is the R console, where R itself lives. You can type commands for R to process into this screen and when entered, R will process them. However, commands entered here are not saved, so making an R script is recommended. This is also where any output from R scripts will appear. A handy feature is if you hit the up arrow on your keyboard, the last command run will appear in the console, allowing for it to be run again. This can be repeated multiple times to more easily run a command you previously used\nThe top right is the environment window. When you import datasets into R or create variables to store information, they will show up here.\nThe bottom right is the information window, where you can access the File, Plots, Packages, and Help tabs. File allows you to access files in your directory for use in RStudio. Plots is where graphs you make will appear. Packages is where the add-on packages you can install and load will appear, and help is a manual for R commands that is easily accessible."
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html#files-location",
    "href": "document_dir/basics/using_rstudio.html#files-location",
    "title": "Using R and RStudio",
    "section": "Files Location",
    "text": "Files Location\nFiles that the RStudio server uses and can access live in your Bowdoin Microwave storage space. This is 10 gigabytes of storage that Bowdoin hosts on their servers that is automatically backed up on a regular basis. This is where you will want to store your data files and R scripts for ease of use. This storage can be accessed by opening the Finder application and clicking the Go button at the top menu bar. Click the Connect to Server… button, which will open a window that looks like the one below.\nTo connect to your Microwave drive, put the drive location in the top field. This will be smb://microwave.bowdoin.edu/home/username with the username being your Bowdoin username. Once you click connect, you will be asked to log in with your Bowdoin credentials. Once you submit your username and password, a finder window will open and contain your Microwave drive."
  },
  {
    "objectID": "document_dir/basics/data_types.html",
    "href": "document_dir/basics/data_types.html",
    "title": "Objects and Data Structures",
    "section": "",
    "text": "Now you know about variables, but what can you store in one? The short answer is everything! R has a wide variety of different data types that are used for different things. I will break down the most common ones you will use in this section. First, there are two distinct categories of data types: atomic data types and data structures.\n\n\nAtomic data types are the most simple data types in R. These are the building blocks of data structures. Base R has the following atomic data types that you will commonly use:\n\nLogical - TRUE or FALSE\nNumeric - 1 or 1.574, or pi\ncharacter - “hello!”, “a”, “STRING”\n\nWhile these data types are simple, they each have their own quirks that can cause confusion when they are first used.\nAdditionally, R does have other atomic data types that this guide will not cover here. They are either not widely used or are for have more advanced use-cases.\n\n\nLogicals are a binary data type, either being TRUE or FALSE. They must be upper case, or else R interprets it as a variable name. Additionally, R interprets TRUE as 1 and FALSE as 0, leading to interesting results when this data type is used with numerics. For example, see what happens when you add TRUE to 5:\n\nTRUE + 5\n\n[1] 6\n\n\nThis functionality can be useful in some cases, but just be aware of it in case you are getting results that do not make sense to you when dealing with logicals. Their primary use is in conditional functions, which we will explore later in this guide.\n\n\n\nNumerics, also called doubles, are numbers. This can be either whole numbers, such as 9 or 3948, or they can be decimals, such as 8.47 or 937.5\n\ntypeof(584)\ntypeof(98.37483277777)\ntypeof(pi)\n\n[1] \"double\"\n[1] \"double\"\n[1] \"double\"\n\n\n\n\n\nCharacter vectors, also called strings, are a set of text characters. Anything located between a pair of double or single quotes will be considered as a character vector. This includes numbers, text, and symbols. If you want to have your character vector contain quotes, you can use a set of single quotes instead of double quotes and vice versa.\nthis_is_a_character_vector &lt;- \"Hi! Many different symbols can be in a character\"\nquotes_in_string &lt;- 'I have switched to \"single quotes\" to allow double quotes'\n\n\n\n\nData structures are more complex data types that are made of the different atomic data types. The most commonly used data structures include:\n\nVectors\nLists\nMatrices\nData frames\nFactors\n\nLets go over what differentiates these data structures.\n\n\nVectors are the most common data structure. They are made of multiple objects of a single atomic data type. The most common way to create a vector is the concatenate function, c(), where each atomic object is separated by a comma:\n\nnum_vector &lt;- c(1, 2, 3)\nnum_vector\n\n[1] 1 2 3\n\n\nVectors are useful as a lot of R functions are vectorized, meaning one function is applied to every object in the given vector.\n\nadding_two &lt;- num_vector + 2\nadding_two\n\n[1] 3 4 5\n\n\nThe most important thing to remember about vectors is that they can only contain one type of atomic data objects. Lets see when we try to break that!\n\nbroken_vector &lt;- c(1, 2, \"hi\")\nbroken_vector\n\n[1] \"1\"  \"2\"  \"hi\"\n\n\nAs you can see, R has converted the numerics 1 and 2 into characters in order for the vector to be created. Be careful of these conversions, as it can cause unintended consequences.\n\n\n\nSo what if you want to have a vector that contains different data types? Well, then you use lists! Lists are just like vectors in that they hold multiple objects, just they are not limited to a single data type. A list can even contain vectors or other lists.\n\ncool_list &lt;- list(1, TRUE, c(\"vector\", \"in\", \"a\", \"list\"))\ncool_list\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] \"vector\" \"in\"     \"a\"      \"list\"  \n\n\n\n\n\nMatrices (the plural for matrix) are two-dimensional vectors. They are made of rows and columns, but every data object stored in them must be of the same type. This means if you store numerics in a matrix, that matrix will only store numerics.\n\nmy_matrix &lt;- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE)\nmy_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n\n#What happens when we try to change one of the data objects in the matrix to a character?\nmy_matrix[1,1] &lt;- \"hi\"\nmy_matrix #It converts all of the data objects into characters!\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"hi\" \"5\"  \"9\"  \"13\" \"17\"\n[2,] \"2\"  \"6\"  \"10\" \"14\" \"18\"\n[3,] \"3\"  \"7\"  \"11\" \"15\" \"19\"\n[4,] \"4\"  \"8\"  \"12\" \"16\" \"20\"\n\n\nWhile matrices are computationally fast due to their simplicity, their limitations can be too restrictive. Additionally, the conversion of object types can cause confusion in downstream applications. This is why we mainly use data frames!\n\n\n\nData frames are to lists what matrices are to vectors. Rather than being limited to the whole object only containing one data type, each column can contain a different data type. This means if you have a spreadsheet of names and heights, you can have one column contain characters (names), and the other column contain numbers (height in inches) without having R convert either column into a different type.\n\nmy_dataframe &lt;- data.frame(Name = c(\"Crosby\", \"Stills\", \"Nash\"), Height = c(70, 68, 72), Nationality = c(\"American\", \"American\", \"British\"))\nmy_dataframe\n\n    Name Height Nationality\n1 Crosby     70    American\n2 Stills     68    American\n3   Nash     72     British\n\n\nData frames will be used greatly throughout this guide due to the versatility and ease of use. Most data sets you will create and explore in biology will work best in this data type, so make sure you understand what differentiates a data frame from the other data structures discussed above!\n\n\nThere are a set of operators related to working with data frames that allow one to extract specific sets of data from the object.\n\n\n\n\n\n\n\n\n\nName\nSymbol\nType\nUsage\n\n\n\n\nNamed element extrator\n$\nSlice\nExtracts and returns the element of a given name, such as a named column\n\n\nSlice list extractor\n[]\nSlice\nExtracts element(s) at a given index location and returns a list of values\n\n\nSlice element extractor\n[[]]\nSlice\nExtracts and returns element(s) at a given index location\n\n\n\n\nmy_dataframe$Name\n\n#The first value in the slice list extractor is the row index number\n#The second value is the column index number, and they are separated by a comma\nmy_dataframe[1,1]\n\n#You can also keep oen of the arguments empty to return all of that type\nmy_dataframe[1,] #Returns all columns of the first row\n\n#If you want to return the element and not a list containing the element, use [[]]\nmy_dataframe[[1,1]]\n\n[1] \"Crosby\" \"Stills\" \"Nash\"  \n[1] \"Crosby\"\n    Name Height Nationality\n1 Crosby     70    American\n[1] \"Crosby\"\n\n\n\n\n\n\n\nThere are three ways to represent missing data in R. For data that does not exist, R has the object NULL. Setting a variable equal to NULL is a way to delete the object that variable is assigned to. If a value is unknown but does exist, then R uses the object NA. Then, in the case of impossible values, such as dividing by zero, R has the object NaN, or not a number."
  },
  {
    "objectID": "document_dir/basics/data_types.html#data-types",
    "href": "document_dir/basics/data_types.html#data-types",
    "title": "Objects and Data Structures",
    "section": "",
    "text": "Now you know about variables, but what can you store in one? The short answer is everything! R has a wide variety of different data types that are used for different things. I will break down the most common ones you will use in this section. First, there are two distinct categories of data types: atomic data types and data structures.\n\n\nAtomic data types are the most simple data types in R. These are the building blocks of data structures. Base R has the following atomic data types that you will commonly use:\n\nLogical - TRUE or FALSE\nNumeric - 1 or 1.574, or pi\ncharacter - “hello!”, “a”, “STRING”\n\nWhile these data types are simple, they each have their own quirks that can cause confusion when they are first used.\nAdditionally, R does have other atomic data types that this guide will not cover here. They are either not widely used or are for have more advanced use-cases.\n\n\nLogicals are a binary data type, either being TRUE or FALSE. They must be upper case, or else R interprets it as a variable name. Additionally, R interprets TRUE as 1 and FALSE as 0, leading to interesting results when this data type is used with numerics. For example, see what happens when you add TRUE to 5:\n\nTRUE + 5\n\n[1] 6\n\n\nThis functionality can be useful in some cases, but just be aware of it in case you are getting results that do not make sense to you when dealing with logicals. Their primary use is in conditional functions, which we will explore later in this guide.\n\n\n\nNumerics, also called doubles, are numbers. This can be either whole numbers, such as 9 or 3948, or they can be decimals, such as 8.47 or 937.5\n\ntypeof(584)\ntypeof(98.37483277777)\ntypeof(pi)\n\n[1] \"double\"\n[1] \"double\"\n[1] \"double\"\n\n\n\n\n\nCharacter vectors, also called strings, are a set of text characters. Anything located between a pair of double or single quotes will be considered as a character vector. This includes numbers, text, and symbols. If you want to have your character vector contain quotes, you can use a set of single quotes instead of double quotes and vice versa.\nthis_is_a_character_vector &lt;- \"Hi! Many different symbols can be in a character\"\nquotes_in_string &lt;- 'I have switched to \"single quotes\" to allow double quotes'\n\n\n\n\nData structures are more complex data types that are made of the different atomic data types. The most commonly used data structures include:\n\nVectors\nLists\nMatrices\nData frames\nFactors\n\nLets go over what differentiates these data structures.\n\n\nVectors are the most common data structure. They are made of multiple objects of a single atomic data type. The most common way to create a vector is the concatenate function, c(), where each atomic object is separated by a comma:\n\nnum_vector &lt;- c(1, 2, 3)\nnum_vector\n\n[1] 1 2 3\n\n\nVectors are useful as a lot of R functions are vectorized, meaning one function is applied to every object in the given vector.\n\nadding_two &lt;- num_vector + 2\nadding_two\n\n[1] 3 4 5\n\n\nThe most important thing to remember about vectors is that they can only contain one type of atomic data objects. Lets see when we try to break that!\n\nbroken_vector &lt;- c(1, 2, \"hi\")\nbroken_vector\n\n[1] \"1\"  \"2\"  \"hi\"\n\n\nAs you can see, R has converted the numerics 1 and 2 into characters in order for the vector to be created. Be careful of these conversions, as it can cause unintended consequences.\n\n\n\nSo what if you want to have a vector that contains different data types? Well, then you use lists! Lists are just like vectors in that they hold multiple objects, just they are not limited to a single data type. A list can even contain vectors or other lists.\n\ncool_list &lt;- list(1, TRUE, c(\"vector\", \"in\", \"a\", \"list\"))\ncool_list\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] \"vector\" \"in\"     \"a\"      \"list\"  \n\n\n\n\n\nMatrices (the plural for matrix) are two-dimensional vectors. They are made of rows and columns, but every data object stored in them must be of the same type. This means if you store numerics in a matrix, that matrix will only store numerics.\n\nmy_matrix &lt;- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE)\nmy_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n\n#What happens when we try to change one of the data objects in the matrix to a character?\nmy_matrix[1,1] &lt;- \"hi\"\nmy_matrix #It converts all of the data objects into characters!\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"hi\" \"5\"  \"9\"  \"13\" \"17\"\n[2,] \"2\"  \"6\"  \"10\" \"14\" \"18\"\n[3,] \"3\"  \"7\"  \"11\" \"15\" \"19\"\n[4,] \"4\"  \"8\"  \"12\" \"16\" \"20\"\n\n\nWhile matrices are computationally fast due to their simplicity, their limitations can be too restrictive. Additionally, the conversion of object types can cause confusion in downstream applications. This is why we mainly use data frames!\n\n\n\nData frames are to lists what matrices are to vectors. Rather than being limited to the whole object only containing one data type, each column can contain a different data type. This means if you have a spreadsheet of names and heights, you can have one column contain characters (names), and the other column contain numbers (height in inches) without having R convert either column into a different type.\n\nmy_dataframe &lt;- data.frame(Name = c(\"Crosby\", \"Stills\", \"Nash\"), Height = c(70, 68, 72), Nationality = c(\"American\", \"American\", \"British\"))\nmy_dataframe\n\n    Name Height Nationality\n1 Crosby     70    American\n2 Stills     68    American\n3   Nash     72     British\n\n\nData frames will be used greatly throughout this guide due to the versatility and ease of use. Most data sets you will create and explore in biology will work best in this data type, so make sure you understand what differentiates a data frame from the other data structures discussed above!\n\n\nThere are a set of operators related to working with data frames that allow one to extract specific sets of data from the object.\n\n\n\n\n\n\n\n\n\nName\nSymbol\nType\nUsage\n\n\n\n\nNamed element extrator\n$\nSlice\nExtracts and returns the element of a given name, such as a named column\n\n\nSlice list extractor\n[]\nSlice\nExtracts element(s) at a given index location and returns a list of values\n\n\nSlice element extractor\n[[]]\nSlice\nExtracts and returns element(s) at a given index location\n\n\n\n\nmy_dataframe$Name\n\n#The first value in the slice list extractor is the row index number\n#The second value is the column index number, and they are separated by a comma\nmy_dataframe[1,1]\n\n#You can also keep oen of the arguments empty to return all of that type\nmy_dataframe[1,] #Returns all columns of the first row\n\n#If you want to return the element and not a list containing the element, use [[]]\nmy_dataframe[[1,1]]\n\n[1] \"Crosby\" \"Stills\" \"Nash\"  \n[1] \"Crosby\"\n    Name Height Nationality\n1 Crosby     70    American\n[1] \"Crosby\"\n\n\n\n\n\n\n\nThere are three ways to represent missing data in R. For data that does not exist, R has the object NULL. Setting a variable equal to NULL is a way to delete the object that variable is assigned to. If a value is unknown but does exist, then R uses the object NA. Then, in the case of impossible values, such as dividing by zero, R has the object NaN, or not a number."
  },
  {
    "objectID": "document_dir/basics/basic_functions.html",
    "href": "document_dir/basics/basic_functions.html",
    "title": "Functions",
    "section": "",
    "text": "At the core of using R is utilizing functions, which are statements that takes in data and a set of parameters and returns an object with something being done to the data provided. Functions are how you read in your data sets, clean them up, do statistical analyses, and visualize your data. You can even make your own!\n\n\nBefore we get into some basic and common functions, one must first understand the components of a function. Below is the mean function, which as the name implies, finds the mean of a given set of values.\n\nfav_nums &lt;- c(1,5,12,8,58) #Making a vector of values\nmean_fav &lt;- mean(x = fav_nums, na.rm = TRUE)\nmean_fav\n\n[1] 16.8\n\n\nThe structure of a function is the function’s name followed by a set of parentheses. For some functions that require no additional information, that is all you need. However, most functions require providing data objects and parameters so that the function is applied to a specific object in a specific way. For example, in the mean()function above, there are two parameters:xandna.rm\\\nIn this case, the x parameter is where we provide the data object that mean() uses. We assign the data object fav_nums to the x parameter using the parameter assignment operator, =. Generally, the very first parameter of a function will be where you provide the data object.\nSimilarly to assigning the fav_nums object to x, the logical value TRUE is assigned to the na.rm parameter, which tells the mean() function to remove any NA values in the provided set of numbers if there was any.\nSomething that makes writing functions easier is that there is a given order of parameters in a specific function. For the mean() function, there are three named parameters: x, trim, and na.rm. Rather than having to provide the parameter name, you can just provide the value for the parameter instead of the full parameter = value statement.\n\nmean_fav &lt;- mean(fav_nums)\nmean_fav\n\n[1] 16.8\n\n\nAdditionally, functions can have some parameters have default values, meaning if you do not provide a value in your function statement, it will automatically use a specific value defined by the function creator. An example of this is for the first usage of the mean() function. I did not provide a value for the trim parameter, yet the function still worked. This is because the mean() function provides a default value for that parameter. You can override that default value by setting the parameter to what you wish. An example is that the default parameter value for na.rm for the mean() function is FALSE, but I set na.rm to TRUE.\nThe most readily available source of information for understanding what a function does and what the specific parameters it uses is the help tab in RStudio. You can search by the function name and it will provide a reference guide to the function."
  },
  {
    "objectID": "document_dir/basics/basic_functions.html#function-syntax",
    "href": "document_dir/basics/basic_functions.html#function-syntax",
    "title": "Functions",
    "section": "",
    "text": "Before we get into some basic and common functions, one must first understand the components of a function. Below is the mean function, which as the name implies, finds the mean of a given set of values.\n\nfav_nums &lt;- c(1,5,12,8,58) #Making a vector of values\nmean_fav &lt;- mean(x = fav_nums, na.rm = TRUE)\nmean_fav\n\n[1] 16.8\n\n\nThe structure of a function is the function’s name followed by a set of parentheses. For some functions that require no additional information, that is all you need. However, most functions require providing data objects and parameters so that the function is applied to a specific object in a specific way. For example, in the mean()function above, there are two parameters:xandna.rm\\\nIn this case, the x parameter is where we provide the data object that mean() uses. We assign the data object fav_nums to the x parameter using the parameter assignment operator, =. Generally, the very first parameter of a function will be where you provide the data object.\nSimilarly to assigning the fav_nums object to x, the logical value TRUE is assigned to the na.rm parameter, which tells the mean() function to remove any NA values in the provided set of numbers if there was any.\nSomething that makes writing functions easier is that there is a given order of parameters in a specific function. For the mean() function, there are three named parameters: x, trim, and na.rm. Rather than having to provide the parameter name, you can just provide the value for the parameter instead of the full parameter = value statement.\n\nmean_fav &lt;- mean(fav_nums)\nmean_fav\n\n[1] 16.8\n\n\nAdditionally, functions can have some parameters have default values, meaning if you do not provide a value in your function statement, it will automatically use a specific value defined by the function creator. An example of this is for the first usage of the mean() function. I did not provide a value for the trim parameter, yet the function still worked. This is because the mean() function provides a default value for that parameter. You can override that default value by setting the parameter to what you wish. An example is that the default parameter value for na.rm for the mean() function is FALSE, but I set na.rm to TRUE.\nThe most readily available source of information for understanding what a function does and what the specific parameters it uses is the help tab in RStudio. You can search by the function name and it will provide a reference guide to the function."
  },
  {
    "objectID": "document_dir/basics/bool_logic.html",
    "href": "document_dir/basics/bool_logic.html",
    "title": "Boolean Logic",
    "section": "",
    "text": "A common practice in statistics and programming in general is comparing data in specific ways. When an evaluation only can return true or false, then that is an example of Boolean logic. For example, if I asked you if the number 1 is in the set of all odd numbers, then the answer would be true. Additionally, if I asked if 5 equals 84, then you would say false. By using Boolean operators, R can evaluate logic expressions and return the logical data type TRUE or FALSE. In addition to the logicals, R treats the number 0 as false and 1 as true.\n\n\nR uses a set of Boolean operators to build comparison expressions.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nGreater than operator\nComparison\n&gt;\nChecks if an object is greater than another object\n\n\nLess than operator\nComparison\n&lt;\nChecks if an object is less than another object\n\n\nEquals operator\nComparison\n==\nCheck if two objects are equal to each other\n\n\nGreater than or equals to operator\nComparison\n&gt;=\nChecks if an object is greater than or equal to another object\n\n\nLess than or equals to operator\nComparison\n&lt;=\nChecks if an object is less than or equal to another object\n\n\nNot equal operator\nComparison\n!=\nChecks if an object is not equal to another object\n\n\nAND operator\nLogical\n&\nReturns true if both objects are true\n\n\nOR operator\nLogical\n|\nReturns true if at least one of the objects is true\n\n\nNOT operator\nLogical\n!\nReturns the opposite logical value of a given object\n\n\nIN operator\nLogical\n%in%\nDetermines if a given object is within another object\n\n\n\nA common function used with logical expressions is the which() function. By giving it a logical expression, it will return the index values of items in a vector-like object that match the expression. For example if I had a data set of famous biologists and I wanted to find which of them specialized in genetics, I would use the which() function.\n\nfamous_biologists &lt;- data.frame(first_name = c(\"Charles\", \"Barbara\", \"Gregor\"),\n                                last_name = c(\"Darwin\", \"McClintock\", \"Mendel\"),\n                                subfield = c(\"evolution\", \"genetics\", \"genetics\"))\nwhich(famous_biologists$subfield == \"genetics\")\n\n[1] 2 3\n\n\nThese results mean that rows 2 and 3 have their sub field category equal to genetics."
  },
  {
    "objectID": "document_dir/basics/bool_logic.html#boolean-operators",
    "href": "document_dir/basics/bool_logic.html#boolean-operators",
    "title": "Boolean Logic",
    "section": "",
    "text": "R uses a set of Boolean operators to build comparison expressions.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nGreater than operator\nComparison\n&gt;\nChecks if an object is greater than another object\n\n\nLess than operator\nComparison\n&lt;\nChecks if an object is less than another object\n\n\nEquals operator\nComparison\n==\nCheck if two objects are equal to each other\n\n\nGreater than or equals to operator\nComparison\n&gt;=\nChecks if an object is greater than or equal to another object\n\n\nLess than or equals to operator\nComparison\n&lt;=\nChecks if an object is less than or equal to another object\n\n\nNot equal operator\nComparison\n!=\nChecks if an object is not equal to another object\n\n\nAND operator\nLogical\n&\nReturns true if both objects are true\n\n\nOR operator\nLogical\n|\nReturns true if at least one of the objects is true\n\n\nNOT operator\nLogical\n!\nReturns the opposite logical value of a given object\n\n\nIN operator\nLogical\n%in%\nDetermines if a given object is within another object\n\n\n\nA common function used with logical expressions is the which() function. By giving it a logical expression, it will return the index values of items in a vector-like object that match the expression. For example if I had a data set of famous biologists and I wanted to find which of them specialized in genetics, I would use the which() function.\n\nfamous_biologists &lt;- data.frame(first_name = c(\"Charles\", \"Barbara\", \"Gregor\"),\n                                last_name = c(\"Darwin\", \"McClintock\", \"Mendel\"),\n                                subfield = c(\"evolution\", \"genetics\", \"genetics\"))\nwhich(famous_biologists$subfield == \"genetics\")\n\n[1] 2 3\n\n\nThese results mean that rows 2 and 3 have their sub field category equal to genetics."
  },
  {
    "objectID": "document_dir/basics/extending_r.html",
    "href": "document_dir/basics/extending_r.html",
    "title": "Extending R",
    "section": "",
    "text": "One of the things that makes R so widely used is the extensive package system. Packages are collections of functions and object types made by other R users to extend the abilities of R. For example, if you were asked to run a set of statistical analyses on a data set in R, you have a few options. You could manually write out the steps of the analysis using the base R functions or you could install and use a package that implements those analyses for you! If you need to do something in R, chances are there is a package you can use that will make that easier.\n\n\n\n\n\nThe largest repository of R packages can be installed from CRAN through a function with only the name of the package needed. For example, if I wanted to install the vegan package, which is a widely used ecological analysis package, I can use this command:\ninstall.packages(\"vegan\")\nThis will then install that package to your R environment. However, if you are on the Bowdoin RStudio server, then the vast majority of packages you may need are already installed. As such, this command is restricted. If you absolutely need to have access to a package not already installed, you can override this restriction by modifying the command:\nutils::install.packages(\"vegan\")\nThis will then install the package to your local Microwave drive and allow you access to the package. The package will only be available to your local R environment, so if someone else needs to use the package, they will have to install it directly as well.\n\n\n\nFor many biology-specific packages, they are accessible from the Bioconductor repository. To install packages from there, you first have to install the Bioconductor core package, then you can install the package you wish to use.\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\") #Installs the core package\nBiocManager::install() #Installs Bioconductor\nBiocManager::install(\"treeio\") #Installs the treeio package\n\n\n\nAdditionally, there is a separate installation method for packages that are not in either of these repositories but are on Github, a code repository site used in industry and academia.\ndevtools::install_github('author_name/repository')\n\n\n\n\nNow that you have a package installed, you have to tell R that it exists so that you can use it. To do so, you use the library() command.\nlibrary(package_name)\n\n\n\n\n\n\nNote\n\n\n\nUnlike installing packages, the package name does not have to be in a set of quotes. This is to make it easier to load packages.\n\n\nThis command can load any package that is installed and will automatically load any other packages that are required for the package to function.\nYou can also see what packages are available and loaded in the Packages tab located in the bottom right panel of RStudio. You can select the check boxes besides packages to load and unload them as well."
  },
  {
    "objectID": "document_dir/basics/extending_r.html#packages",
    "href": "document_dir/basics/extending_r.html#packages",
    "title": "Extending R",
    "section": "",
    "text": "One of the things that makes R so widely used is the extensive package system. Packages are collections of functions and object types made by other R users to extend the abilities of R. For example, if you were asked to run a set of statistical analyses on a data set in R, you have a few options. You could manually write out the steps of the analysis using the base R functions or you could install and use a package that implements those analyses for you! If you need to do something in R, chances are there is a package you can use that will make that easier.\n\n\n\n\n\nThe largest repository of R packages can be installed from CRAN through a function with only the name of the package needed. For example, if I wanted to install the vegan package, which is a widely used ecological analysis package, I can use this command:\ninstall.packages(\"vegan\")\nThis will then install that package to your R environment. However, if you are on the Bowdoin RStudio server, then the vast majority of packages you may need are already installed. As such, this command is restricted. If you absolutely need to have access to a package not already installed, you can override this restriction by modifying the command:\nutils::install.packages(\"vegan\")\nThis will then install the package to your local Microwave drive and allow you access to the package. The package will only be available to your local R environment, so if someone else needs to use the package, they will have to install it directly as well.\n\n\n\nFor many biology-specific packages, they are accessible from the Bioconductor repository. To install packages from there, you first have to install the Bioconductor core package, then you can install the package you wish to use.\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\") #Installs the core package\nBiocManager::install() #Installs Bioconductor\nBiocManager::install(\"treeio\") #Installs the treeio package\n\n\n\nAdditionally, there is a separate installation method for packages that are not in either of these repositories but are on Github, a code repository site used in industry and academia.\ndevtools::install_github('author_name/repository')\n\n\n\n\nNow that you have a package installed, you have to tell R that it exists so that you can use it. To do so, you use the library() command.\nlibrary(package_name)\n\n\n\n\n\n\nNote\n\n\n\nUnlike installing packages, the package name does not have to be in a set of quotes. This is to make it easier to load packages.\n\n\nThis command can load any package that is installed and will automatically load any other packages that are required for the package to function.\nYou can also see what packages are available and loaded in the Packages tab located in the bottom right panel of RStudio. You can select the check boxes besides packages to load and unload them as well."
  },
  {
    "objectID": "document_dir/basics/extending_r.html#user-defined-functions",
    "href": "document_dir/basics/extending_r.html#user-defined-functions",
    "title": "Extending R",
    "section": "User-defined Functions",
    "text": "User-defined Functions\n\nWhat are they?\nUser-defined functions are functions that are made by you for your use. By making your own function, you can turn a multistep process that you may need to run many times into something that can be done in a single line of R code.\nFor example, if you had to regularly edit a data frame, find the mean of the values in a specific column, and create a new data frame using another set of rows, Instead of writing out the list of functions to do this every time it is needed, you can simply write it once when you declare your function and then use that single function to get your results.\n\n\nSyntax\nMaking your own functions follows a simple syntax that uses function()\nfunction_name &lt;- function(parameter1, parameter2) {\n  var1 &lt;- parameter1*parameter2\n  var2 &lt;- var1+parameter2*mean(c(parameter1, parameter2))\n  return(var2)\n  }\nThe name of your function is the variable you are assigning the function() call to. Any parameters necessary for your function are declared within the function() call. Then, in the curly braces, you write the functions that are done when you use your function. You then finish with the return() function. The variable in the return() function is what your function will output when used.\nOnce declared, you can then use your function like you would use any other function."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An R Guide for Bowdoin Biology Students",
    "section": "",
    "text": "Welcome to the guide for using R as a biology student at Bowdoin College! This guide will act as a comprehensive introduction to the R statistical programming language and its applications in the field of biology. Included in this guide are: an introduction to using R, an overview of R structure, data manipulation, data visualization/graphing, statistical analyses, biology-specific packages, and intermediate/advanced R use cases. This guide can be used by complete R beginners, people with experience with other programming languages, and even people with R experience outside the field of biology.\n\nWhat is R?\nR is a statistical programming language developed by Ross Ihaka and Robert Gentleman.1 Based on the principles of free (as in freedom) open source software (FOSS), the R programming language is freely available at the Comprehensive R Archive Newtork (CRAN) and can run on Windows, Linus, and MacOS platforms.\nSo why use R instead of other statistical packages, such as SPSS, SAS, Stata, Prism, or others?\n\nIt is a standard tool in most academic disciplines that use statistical analyses for research and industry.2 In fact, over 54% of all published literature articles in the top 30 journals in ecology used R.3\nR has an active community supporting it. Tens of thousands of packages, the main way of extended R’s capabilities, have been created and are actively maintained.4\nDue to its open source nature, the source code can be freely investigated, ensuring confidence in its accuracy.\nIt is free!\n\n\n\nWhat can I do with R?\nR is a programming language, so almost anything you can think of! However, you most likely would not want to make a video game using R. R is specialized to statistical analysis and data science. We will be using it to process our data, run statistical tests, and to graph our results. However, this is just the tip of the iceberg of what you can do with R! From analyzing genomic data sets, to creating machine learning models, to GIS analysis, R can do it all and even more.\n\n\nHow do I use this guide?\nThis guide is broken into different sections that each cover information about R. In these sections, there will be text explanations such as this, and also code blocks with relevant R code. By pressing the “Run code” button, the program will run and you will be able to see the results below the block. For example, try this simple code block:\nLoading\n  webR...\n\n\n  \n\n\nIf it was successful, then you should see a result that says 2. Additionally, there will be some code blocks without the “Run code” button, which are just to explain specific concepts. See below:\nvar &lt;- 1\ntwo.var &lt;- var + var\nFor some code blocks, there will be code annotations on the right side that appear when you hover your mouse cursor over the icon.\n1var &lt;- 1\n\n1\n\nHere is a code annotation!\n\n\n\n\n\n\n\nReferences\n\n1. Giorgi FM, Ceraolo C, Mercatelli D. The r language: An engine for bioinformatics and data science. Life. 2022;12(5):648. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9148156/. doi:10.3390/life12050648\n\n\n2. Muenchen R. The popularity of data science software | r4stats.com. 2012. https://r4stats.com/articles/popularity/\n\n\n3. Lai J, Lortie CJ, Muenchen RA, Yang J, Ma K. Evaluating the popularity of R in ecology. Ecosphere. 2019;10(1):e02567. https://onlinelibrary.wiley.com/doi/abs/10.1002/ecs2.2567. doi:10.1002/ecs2.2567\n\n\n4. The comprehensive r archive network. https://cran.r-project.org/"
  }
]